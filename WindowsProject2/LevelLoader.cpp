#include "LevelLoader.h"
#include "GameLoop.h"
#include "RenderBullshit.h"
#include "DisplayableThing.h"
#include "AIPossessor.h"
#include <assert.h>
#include "tmxlite\Map.hpp"
#include "tmxlite\Tileset.hpp"
#include "tmxlite\TileLayer.hpp"

#include "Robot.h"
#include "Slime.h"

#include "FPSCounter.h"
#include "Camera.h"
#include "HumanPossessor.h"
#include "BackGroundTileDisplayable.h"
#include "SpriteSheet.h"
#include "GString.h"

#include <vector>

LevelLoader::LevelLoader() :
	_game_loop(nullptr),
	_render_thing(nullptr),
	_hid_state(nullptr),
	_sheets(8)
{
}

LevelLoader::~LevelLoader()
{
	for (int i = 0; i < _sheets.count(); i++)
	{
		delete _sheets[i];
	}
	_sheets.clear();
}

void LevelLoader::loadLevel()
{
	assert(_game_loop);
	assert(_render_thing);
	assert(_hid_state);

	if (0)
	{
		Possessor* poss = new AIPossessor();
		DisplayableThing* thing = new DisplayableThing(1, 1, 50, 50);
		thing->setPossesor(poss);
		poss->setControllable(thing);
		_render_thing->addDisplayableObject(thing);
		_game_loop->addUpdatableObject(thing);
	}

	if (0)
	{
		Possessor* poss = new AIPossessor();
		DisplayableThing* thing = new DisplayableThing(50, 50, 50, 50);
		thing->setPossesor(poss);
		poss->setControllable(thing);
		_render_thing->addDisplayableObject(thing);
		_game_loop->addUpdatableObject(thing);
	}

	tmx::Map map;
	if (!map.load("E:\\Keith\\Documents\\TheBigGame\\Mapping\\images\\map3.tmx"))
	{
		OutputDebugString(TEXT("Couldn't load tmx map\n"));
	}
	OutputDebugString(TEXT("Loaded tmx map\n"));

	std::vector<tmx::Tileset> tilesets = map.getTilesets();
	if (tilesets.empty())
		return;
		
	GMap<int, DynamicList<RECTF_TYPE>> tile_collision_walls;
	int gid_offsets[256];
	for (int i = 0; i < tilesets.size(); i++)
	{
#if 1

		// This will determine all the IDs that have collision
		const std::vector<tmx::Tileset::Tile>& tiles = tilesets[i].getTiles();
		for (int tile_props = 0; tile_props < tiles.size(); ++tile_props)
		{
			// these are turned off temp
			//if (i == 0/* && tiles[tile_props].objectGroup.getObjects().size()*/)
			{
				for (int rect = 0; rect < tiles[tile_props].objectGroup.getObjects().size(); rect++)
				{
					// coming out of tag:x="7.27273" y="6.90909" width="24.1818" height="24.7273"
					RECTF_TYPE new_rect;
					new_rect.left = tiles[tile_props].objectGroup.getObjects().at(rect).getAABB().left;
					new_rect.right = tiles[tile_props].objectGroup.getObjects().at(rect).getAABB().width + new_rect.left;
					new_rect.top = tiles[tile_props].objectGroup.getObjects().at(rect).getAABB().top;
					new_rect.bottom = tiles[tile_props].objectGroup.getObjects().at(rect).getAABB().height + new_rect.top;
					if (tiles[tile_props].ID + tilesets[i].getFirstGID() == 37)
						OutputDebugString(TEXT("pause\n"));
					tile_collision_walls[tiles[tile_props].ID + tilesets[i].getFirstGID()].append(new_rect);
				}
				//tiles_w_collisions.append(tile_props);
			}
			// turned off temp
			//else
			{
				OutputDebugString(TEXT("Didn't get collisions\n"));
			}
		}
#endif

		GString gstr(tilesets[i].getImagePath());
		OutputDebugString(gstr.toWideString().c_str());
		OutputDebugString(TEXT("\n"));

		int width = 0, height = 0;
		tilesets[i].getImageConstraints(width, height);
		gid_offsets[i] = tilesets[i].getFirstGID();
		int image_handle = _render_thing->loadBitmapAssetFromFilepath(tilesets[i].getImagePath(), width, height);

		int tile_width  = tilesets[i].getTileSize().x;
		int tile_height = tilesets[i].getTileSize().y;
		int max_cols    = tilesets[i].getColumnCount();
		
		_sheets.append(new SpriteSheet(image_handle, tile_width, tile_height, max_cols));
	}// end of tiles

	const std::vector<tmx::Layer::Ptr>& layers = map.getLayers();
	for (int layer_i = 0; layer_i < layers.size(); layer_i++)
	{
		if (layers[layer_i]->getType() == tmx::Layer::Type::Tile)
		{
			tmx::Layer* layer = layers[layer_i].get();
			tmx::TileLayer* tile_layer = static_cast<tmx::TileLayer*>(layer);
			const std::vector<tmx::TileLayer::Tile> tiles = tile_layer->getTiles();

			// loop through actual data now..
			for (int i = 0; i < tiles.size(); i++)
			{
				int ndx = 0; // this is her for temp just to keep things running
				int first_gid_of_sprite_sheet = 1; // this needs to be generated by the tmx file

				DisplayableBitmap* thing = new BackGroundTileDisplayable();
				int id = tiles.at(i).ID; // needs to be first gid
				int col = (id - gid_offsets[ndx]) % _sheets[ndx]->maxColumns();
				int row = (id - gid_offsets[ndx]) / _sheets[ndx]->maxColumns();

				// This will determine if the tile needs to collide like a wall
				int offset_id = id;// -gid_offsets[ndx];
				if (tile_collision_walls.count(offset_id))
				{
					// why is 8 getting in here?
					thing->setSolid(true);
					for (int rect = 0; rect < tile_collision_walls[offset_id].count(); rect++)
						thing->addTinyCollisionBoxesForStage2Detect(tile_collision_walls[offset_id].at(rect));
					//tile_collision_walls[tile_props].append
				}

				// There needs to be a bit that offsets the ID to spritesheet gid-starting point needs to be used
				// there needs to be a bit that determintes which sprite sheet is being used

				thing->setSprite(_sheets[ndx]->createSprite(col, row)); // this needs to 
				int tile_count_in_width = 50; // TODO: set this number from data!
				float x = (float)((int)(i % tile_count_in_width))*_sheets[ndx]->getSpriteWidth();
				float y = (float)((int)(i / tile_count_in_width))*_sheets[ndx]->getSpriteHeight();

				thing->setWorldCoordinates(x, y);
				_render_thing->addDisplayableObject(thing, layer_i);
				_game_loop->addUpdatableObject(thing);
			}
		}
		if (layers[layer_i]->getType() == tmx::Layer::Type::Object)
		{
			tmx::Layer* layer = layers[layer_i].get();
			tmx::ObjectGroup* obj_layer = static_cast<tmx::ObjectGroup*>(layer);

			const std::vector<tmx::Object>& objects = obj_layer->getObjects();
			for (int i = 0; i < objects.size(); ++i)
			{
				// create the player stuff
				if (objects.at(i).getType() == "Robot")
				{
					float x = objects.at(i).getPosition().x;
					float y = objects.at(i).getPosition().y;
					
					Possessor* poss = new HumanPossessor(_hid_state);
					Robot *thing = new Robot(x, y, 32, 32);

					//objects.at(i).getTileID();
					// TODO: use newly minted sprite manager
					thing->setSprite(_sheets[1]->createSprite(0, 0));
					
					// TODO: this shouldn't be hard coded
					thing->addTinyCollisionBoxesForStage2Detect(tile_collision_walls[37].front());


					thing->setPossesor(poss);
					poss->setControllable(thing);
					_render_thing->addDisplayableObject(thing);
					_render_thing->getCamera()->centerScreenOnThisGuy(thing);
					_game_loop->addUpdatableObject(_render_thing->getCamera());
					_game_loop->addUpdatableObject(thing);
				}
				else if (objects.at(i).getType() == "Slime")
				{
					float x = objects.at(i).getPosition().x;
					float y = objects.at(i).getPosition().y;
					Slime *thing = new Slime(x, y, 32, 32);

					Possessor* poss = new AIPossessor();
					thing->setPossesor(poss);
					poss->setControllable(thing);

					// TODO: this shouldn't be hard coded
					thing->addTinyCollisionBoxesForStage2Detect(tile_collision_walls[41].front());

					//objects.at(i).getTileID();
					// TODO: use newly minted sprite manager
					thing->setSprite(_sheets[2]->createSprite(0, 0));

					_render_thing->addDisplayableObject(thing);
					_game_loop->addUpdatableObject(thing);
				}
			}
		}
	}

	// Set up camera stuff
	if (0)
	{
		// this will give user controllable camera
		Possessor* poss = new HumanPossessor(_hid_state);
		_render_thing->getCamera()->setPossesor(poss);
		poss->setControllable(_render_thing->getCamera()); // this is redundant... code needs much refactoring!
		_game_loop->addUpdatableObject(_render_thing->getCamera());
	}
	else
	{
#if 0
		// this will create a thing to control
		Possessor* poss = new HumanPossessor(_hid_state);
		Robot *thing = new Robot(100, 100, 64, 64);
		thing->setSprite(_sheets[1]->createSprite(0,0));
		thing->setPossesor(poss);
		poss->setControllable(thing);
		_render_thing->addDisplayableObject(thing);
		_render_thing->getCamera()->centerScreenOnThisGuy(thing);
		_game_loop->addUpdatableObject(_render_thing->getCamera());
		_game_loop->addUpdatableObject(thing);
#endif
	}

	FPSCounter* fps_counter = new FPSCounter(0, 0, 100, 10);
	_render_thing->addDisplayableObject(fps_counter);
	_game_loop->addUpdatableObject(fps_counter);
}
